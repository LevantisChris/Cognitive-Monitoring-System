<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/levantis/logmyself/background/BackgroundMonitoringService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/levantis/logmyself/background/BackgroundMonitoringService.kt" />
              <option name="originalContent" value="package com.levantis.logmyself.background&#10;&#10;import android.Manifest&#10;import android.R&#10;import android.app.ActivityManager&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.content.pm.PackageManager&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import androidx.core.app.NotificationCompat&#10;import androidx.work.OneTimeWorkRequestBuilder&#10;import androidx.work.WorkManager&#10;import com.google.android.gms.location.ActivityRecognition&#10;import com.google.android.gms.location.ActivityTransition&#10;import com.google.android.gms.location.ActivityTransitionRequest&#10;import com.google.android.gms.location.DetectedActivity&#10;import com.levantis.logmyself.auth.AuthManager&#10;import com.levantis.logmyself.database.data.AppHeartbeatData&#10;import com.levantis.logmyself.database.util.DatabaseProvider&#10;import com.levantis.logmyself.sensors.DetectorsManager&#10;import com.levantis.logmyself.sensors.receivers.ActivityRecognitionReceiver&#10;import com.levantis.logmyself.sensors.receivers.IntentEvtReceiver&#10;import java.time.LocalDateTime&#10;import java.util.concurrent.TimeUnit&#10;&#10;class BackgroundMonitoringService : Service() {&#10;&#10;    private lateinit var detectorsManager: DetectorsManager&#10;&#10;    // Handler - Appheartbeat&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val heartbeatIntervalMillis = 5 * 60 * 1000L // 5 minutes&#10;    private val heartbeatRunnable = object : Runnable {&#10;        override fun run() {&#10;            logHeartbeat(true) // true = service is alive&#10;            handler.postDelayed(this, heartbeatIntervalMillis)&#10;        }&#10;    }&#10;&#10;    // Reference&#10;    private var intentEvtReceiver: IntentEvtReceiver? = null&#10;&#10;    @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;&#10;        // Start foreground service immediately to avoid &quot;did not start in time&quot; exception&#10;        createNotificationChannel()&#10;        val notification: Notification = NotificationCompat.Builder(this, &quot;MonitoringServiceChannel&quot;)&#10;            .setContentTitle(&quot;Monitoring in Background&quot;)&#10;            .setContentText(&quot;Gathering sleep, drop, and light data.&quot;)&#10;            .setSmallIcon(R.drawable.ic_menu_info_details)&#10;            .build()&#10;        startForeground(1, notification)&#10;&#10;        detectorsManager = DetectorsManager(this)&#10;&#10;        // The service must not start if the user is not authenticated&#10;        if (!AuthManager.isUserAuthenticated()) {&#10;            Log.i(&quot;BackgroundMonitoringService&quot;, &quot;User not authenticated. Stopping service.&quot;)&#10;            stopSelf()&#10;            return&#10;        }&#10;&#10;        // Initialize the database&#10;        DatabaseProvider.getDatabase(this)&#10;&#10;        // Initialize DetectorsManager and start monitoring&#10;        detectorsManager.startMonitoringDropDetection() // does not need any permission&#10;        detectorsManager.startMonitoringLowLightDetection() // only WAKE_LOCK permission is needed (also might need light sensor permission, but this is handled in the class)&#10;        detectorsManager.startMonitoringSleepDetection() // needs Activity Detection permission&#10;        detectorsManager.startMonitoringCallDetection() // needs call permissions&#10;        detectorsManager.startMonitoringFusionLocationDetector() // needs location permissions (at least one)&#10;        detectorsManager.startMonitoringProximityDetector() // does not need any permission&#10;        detectorsManager.startMonitoringNotificationDetector() // needs notification permission&#10;&#10;        registerAllReceivers()&#10;&#10;        // Start app heartbeat logging&#10;        handler.post(heartbeatRunnable)&#10;    }&#10;&#10;    private fun logHeartbeat(status: Boolean) {&#10;        val appHeartBeatData = AppHeartbeatData(&#10;            timestamp = LocalDateTime.now(),&#10;            status = status&#10;        )&#10;        DatabaseProvider.insertAppHeartbeatData(this, appHeartBeatData)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        // Keep the service running&#10;        return START_STICKY&#10;    }&#10;&#10;    override fun onTaskRemoved(rootIntent: Intent?) {&#10;        super.onTaskRemoved(rootIntent)&#10;        Log.i(&quot;BackgroundMonitoringService&quot;, &quot;Task removed&quot;)&#10;    }&#10;&#10;    @RequiresPermission(Manifest.permission.ACTIVITY_RECOGNITION)&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        Log.i(&quot;BackgroundMonitoringService&quot;, &quot;Service destroyed&quot;)&#10;        // Unregister receivers to avoid memory leaks&#10;        try {&#10;            intentEvtReceiver?.let {&#10;                unregisterReceiver(it)&#10;                intentEvtReceiver = null&#10;            }&#10;        } catch (e: IllegalArgumentException) {&#10;            Log.w(&quot;BackgroundMonitoringService&quot;, &quot;Receiver already unregistered&quot;, e)&#10;        }&#10;&#10;        // Remove activity recognition updates&#10;        val client = ActivityRecognition.getClient(this)&#10;        val activityRecognitionIntent = Intent(this, ActivityRecognitionReceiver::class.java)&#10;        val activityRecognitionPendingIntent = PendingIntent.getBroadcast(&#10;            this, 0, activityRecognitionIntent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;        client.removeActivityUpdates(activityRecognitionPendingIntent)&#10;&#10;        // Remove activity transition updates&#10;        val activityTransitionPendingIntent = PendingIntent.getBroadcast(&#10;            this, 1, activityRecognitionIntent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;        client.removeActivityTransitionUpdates(activityTransitionPendingIntent)&#10;&#10;        // Remove Notification&#10;&#10;        // Stop all detectors&#10;        stopAllDetectors()&#10;&#10;        if (AuthManager.isUserAuthenticated()) restartService()&#10;    }&#10;&#10;    private fun stopAllDetectors() {&#10;        detectorsManager.stopMonitoringDropDetection()&#10;        detectorsManager.stopMonitoringLowLightDetection()&#10;        detectorsManager.stopMonitoringSleepDetection()&#10;        detectorsManager.stopMonitoringCallDetection()&#10;        detectorsManager.stopMonitoringFusionLocationDetector()&#10;        detectorsManager.stopMonitoringProximityDetector()&#10;        detectorsManager.stopMonitoringNotificationDetector() // This will disable the also disable the permission for notifications, so the user after log in again will have to enable it again, the app request it again&#10;    }&#10;&#10;    /*&#10;    * Make sure the app restarts after the termination of it (AlarmManager) */&#10;//    private fun restartService() {&#10;//        val restartIntent = Intent(applicationContext, BackgroundMonitoringService::class.java).also {&#10;//            it.setPackage(packageName)&#10;//        }&#10;//&#10;//        val restartPendingIntent = PendingIntent.getService(&#10;//            this, 1, restartIntent, PendingIntent.FLAG_IMMUTABLE&#10;//        )&#10;//&#10;//        try {&#10;//            val alarmManager = getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;//            if (alarmManager.canScheduleExactAlarms()) {&#10;//                alarmManager.setExact(&#10;//                    AlarmManager.ELAPSED_REALTIME_WAKEUP,&#10;//                    SystemClock.elapsedRealtime() + 5000,  // 5 seconds later&#10;//                    restartPendingIntent&#10;//                )&#10;//            } else {&#10;//                Log.e(&quot;BackgroundMonitoringService&quot;, &quot;Cannot schedule exact alarms. Permission not granted.&quot;)&#10;//            }&#10;//        } catch (e: SecurityException) {&#10;//            Log.e(&quot;BackgroundMonitoringService&quot;, &quot;Failed to schedule exact alarm due to SecurityException&quot;, e)&#10;//        }&#10;//    }&#10;&#10;    /* Make sure the app restarts after the termination of it (WorkManager) */&#10;    private fun restartService() {&#10;        if (!isServiceRunning(this, BackgroundMonitoringService::class.java)) {&#10;            val workRequest = OneTimeWorkRequestBuilder&lt;RestartServiceWorker&gt;()&#10;                .setInitialDelay(5, TimeUnit.SECONDS) // Delay of 5 seconds&#10;                .build()&#10;&#10;            WorkManager.getInstance(this).enqueue(workRequest)&#10;        } else {&#10;            Log.i(&quot;BackgroundMonitoringService&quot;, &quot;Service is already running. No need to restart.&quot;)&#10;        }&#10;    }&#10;&#10;    private fun isServiceRunning(context: Context, serviceClass: Class&lt;*&gt;): Boolean {&#10;        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager&#10;        for (service in activityManager.getRunningServices(Int.MAX_VALUE)) {&#10;            if (serviceClass.name == service.service.className) {&#10;                return true&#10;            }&#10;        }&#10;        return false&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? {&#10;        return null&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        val channel = NotificationChannel(&#10;            &quot;MonitoringServiceChannel&quot;,&#10;            &quot;Monitoring Service Channel&quot;,&#10;            NotificationManager.IMPORTANCE_LOW&#10;        )&#10;        val manager = getSystemService(NotificationManager::class.java)&#10;        manager?.createNotificationChannel(channel)&#10;    }&#10;&#10;    private fun registerAllReceivers() {&#10;        // Register screen state receivers&#10;        val intentFilter = IntentFilter().apply {&#10;            addAction(Intent.ACTION_SCREEN_ON)&#10;            addAction(Intent.ACTION_SCREEN_OFF)&#10;            addAction(Intent.ACTION_USER_PRESENT)&#10;            addAction(Intent.ACTION_POWER_CONNECTED)&#10;            addAction(Intent.ACTION_POWER_DISCONNECTED)&#10;        }&#10;        intentEvtReceiver = IntentEvtReceiver()&#10;        registerReceiver(intentEvtReceiver, intentFilter)&#10;&#10;        // Register activity recognition&#10;        registerActivityUpdates()&#10;        registerActivityTransitions()&#10;    }&#10;&#10;    private fun registerActivityUpdates() {&#10;        val client = ActivityRecognition.getClient(this)&#10;        val intent = Intent(this, ActivityRecognitionReceiver::class.java)&#10;        val pendingIntent = PendingIntent.getBroadcast(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;&#10;        if (checkSelfPermission(Manifest.permission.ACTIVITY_RECOGNITION) == PackageManager.PERMISSION_GRANTED) {&#10;            client.requestActivityUpdates(10_000L, pendingIntent)&#10;                .addOnSuccessListener {&#10;                    Log.d(&quot;ActivityRecognition&quot;, &quot;Regular updates registered&quot;)&#10;                }&#10;                .addOnFailureListener {&#10;                    Log.e(&quot;ActivityRecognition&quot;, &quot;Failed to register regular updates&quot;, it)&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun registerActivityTransitions() {&#10;        val client = ActivityRecognition.getClient(this)&#10;        val intent = Intent(this, ActivityRecognitionReceiver::class.java)&#10;        val pendingIntent = PendingIntent.getBroadcast(&#10;            this, 1, intent, // different requestCode&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;&#10;        val transitions = listOf(&#10;            DetectedActivity.IN_VEHICLE,&#10;            DetectedActivity.ON_BICYCLE,&#10;            DetectedActivity.WALKING,&#10;            DetectedActivity.RUNNING,&#10;            DetectedActivity.STILL,&#10;        ).flatMap { activityType -&gt;&#10;            listOf(&#10;                ActivityTransition.Builder()&#10;                    .setActivityType(activityType)&#10;                    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_ENTER)&#10;                    .build(),&#10;                ActivityTransition.Builder()&#10;                    .setActivityType(activityType)&#10;                    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_EXIT)&#10;                    .build()&#10;            )&#10;        }&#10;&#10;        val request = ActivityTransitionRequest(transitions)&#10;&#10;        if (checkSelfPermission(Manifest.permission.ACTIVITY_RECOGNITION) == PackageManager.PERMISSION_GRANTED) {&#10;            client.requestActivityTransitionUpdates(request, pendingIntent)&#10;                .addOnSuccessListener {&#10;                    Log.d(&quot;ActivityRecognition&quot;, &quot;Transition updates registered&quot;)&#10;                }&#10;                .addOnFailureListener {&#10;                    Log.e(&quot;ActivityRecognition&quot;, &quot;Failed to register transitions&quot;, it)&#10;                }&#10;        } else {&#10;            Log.e(&quot;BackgroundMonitoringService&quot;, &quot;Permission not granted for activity recognition&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.levantis.logmyself.background&#10;&#10;import android.Manifest&#10;import android.R&#10;import android.app.ActivityManager&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.content.pm.PackageManager&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import androidx.core.app.NotificationCompat&#10;import androidx.work.OneTimeWorkRequestBuilder&#10;import androidx.work.WorkManager&#10;import com.google.android.gms.location.ActivityRecognition&#10;import com.google.android.gms.location.ActivityTransition&#10;import com.google.android.gms.location.ActivityTransitionRequest&#10;import com.google.android.gms.location.DetectedActivity&#10;import com.levantis.logmyself.auth.AuthManager&#10;import com.levantis.logmyself.database.data.AppHeartbeatData&#10;import com.levantis.logmyself.database.util.DatabaseProvider&#10;import com.levantis.logmyself.sensors.DetectorsManager&#10;import com.levantis.logmyself.sensors.receivers.ActivityRecognitionReceiver&#10;import com.levantis.logmyself.sensors.receivers.IntentEvtReceiver&#10;import java.time.LocalDateTime&#10;import java.util.concurrent.TimeUnit&#10;&#10;class BackgroundMonitoringService : Service() {&#10;&#10;    private lateinit var detectorsManager: DetectorsManager&#10;&#10;    // Handler - Appheartbeat&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val heartbeatIntervalMillis = 5 * 60 * 1000L // 5 minutes&#10;    private val heartbeatRunnable = object : Runnable {&#10;        override fun run() {&#10;            logHeartbeat(true) // true = service is alive&#10;            handler.postDelayed(this, heartbeatIntervalMillis)&#10;        }&#10;    }&#10;&#10;    // Reference&#10;    private var intentEvtReceiver: IntentEvtReceiver? = null&#10;&#10;    @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;&#10;        // Start foreground service immediately to avoid &quot;did not start in time&quot; exception&#10;        createNotificationChannel()&#10;        val notification: Notification = NotificationCompat.Builder(this, &quot;MonitoringServiceChannel&quot;)&#10;            .setContentTitle(&quot;Monitoring in Background&quot;)&#10;            .setContentText(&quot;Gathering sleep, drop, and light data.&quot;)&#10;            .setSmallIcon(R.drawable.ic_menu_info_details)&#10;            .build()&#10;        startForeground(1, notification)&#10;&#10;        detectorsManager = DetectorsManager(this)&#10;&#10;        // The service must not start if the user is not authenticated&#10;        if (!AuthManager.isUserAuthenticated()) {&#10;            Log.i(&quot;BackgroundMonitoringService&quot;, &quot;User not authenticated. Stopping service.&quot;)&#10;            stopSelf()&#10;            return&#10;        }&#10;&#10;        // Initialize the database&#10;        DatabaseProvider.getDatabase(this)&#10;&#10;        // Initialize DetectorsManager and start monitoring&#10;        detectorsManager.startMonitoringDropDetection() // does not need any permission&#10;        detectorsManager.startMonitoringLowLightDetection() // only WAKE_LOCK permission is needed (also might need light sensor permission, but this is handled in the class)&#10;        detectorsManager.startMonitoringSleepDetection() // needs Activity Detection permission&#10;        detectorsManager.startMonitoringCallDetection() // needs call permissions&#10;        detectorsManager.startMonitoringFusionLocationDetector() // needs location permissions (at least one)&#10;        detectorsManager.startMonitoringProximityDetector() // does not need any permission&#10;        detectorsManager.startMonitoringNotificationDetector() // needs notification permission&#10;&#10;        registerAllReceivers()&#10;&#10;        // Start app heartbeat logging&#10;        handler.post(heartbeatRunnable)&#10;    }&#10;&#10;    private fun logHeartbeat(status: Boolean) {&#10;        val appHeartBeatData = AppHeartbeatData(&#10;            timestamp = LocalDateTime.now(),&#10;            status = status&#10;        )&#10;        DatabaseProvider.insertAppHeartbeatData(this, appHeartBeatData)&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        // Keep the service running&#10;        return START_STICKY&#10;    }&#10;&#10;    override fun onTaskRemoved(rootIntent: Intent?) {&#10;        super.onTaskRemoved(rootIntent)&#10;        Log.i(&quot;BackgroundMonitoringService&quot;, &quot;Task removed&quot;)&#10;    }&#10;&#10;    @RequiresPermission(Manifest.permission.ACTIVITY_RECOGNITION)&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        Log.i(&quot;BackgroundMonitoringService&quot;, &quot;Service destroyed&quot;)&#10;        // Unregister receivers to avoid memory leaks&#10;        try {&#10;            intentEvtReceiver?.let {&#10;                unregisterReceiver(it)&#10;                intentEvtReceiver = null&#10;            }&#10;        } catch (e: IllegalArgumentException) {&#10;            Log.w(&quot;BackgroundMonitoringService&quot;, &quot;Receiver already unregistered&quot;, e)&#10;        }&#10;&#10;        // Remove activity recognition updates&#10;        val client = ActivityRecognition.getClient(this)&#10;        val activityRecognitionIntent = Intent(this, ActivityRecognitionReceiver::class.java)&#10;        val activityRecognitionPendingIntent = PendingIntent.getBroadcast(&#10;            this, 0, activityRecognitionIntent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;        client.removeActivityUpdates(activityRecognitionPendingIntent)&#10;&#10;        // Remove activity transition updates&#10;        val activityTransitionPendingIntent = PendingIntent.getBroadcast(&#10;            this, 1, activityRecognitionIntent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;        client.removeActivityTransitionUpdates(activityTransitionPendingIntent)&#10;&#10;        // Remove Notification&#10;&#10;        // Stop all detectors&#10;        stopAllDetectors()&#10;&#10;        if (AuthManager.isUserAuthenticated()) restartService()&#10;    }&#10;&#10;    private fun stopAllDetectors() {&#10;        detectorsManager.stopMonitoringDropDetection()&#10;        detectorsManager.stopMonitoringLowLightDetection()&#10;        detectorsManager.stopMonitoringSleepDetection()&#10;        detectorsManager.stopMonitoringCallDetection()&#10;        detectorsManager.stopMonitoringFusionLocationDetector()&#10;        detectorsManager.stopMonitoringProximityDetector()&#10;        detectorsManager.stopMonitoringNotificationDetector() // This will disable the also disable the permission for notifications, so the user after log in again will have to enable it again, the app request it again&#10;    }&#10;&#10;    /*&#10;    * Make sure the app restarts after the termination of it (AlarmManager) */&#10;//    private fun restartService() {&#10;//        val restartIntent = Intent(applicationContext, BackgroundMonitoringService::class.java).also {&#10;//            it.setPackage(packageName)&#10;//        }&#10;//&#10;//        val restartPendingIntent = PendingIntent.getService(&#10;//            this, 1, restartIntent, PendingIntent.FLAG_IMMUTABLE&#10;//        )&#10;//&#10;//        try {&#10;//            val alarmManager = getSystemService(Context.ALARM_SERVICE) as AlarmManager&#10;//            if (alarmManager.canScheduleExactAlarms()) {&#10;//                alarmManager.setExact(&#10;//                    AlarmManager.ELAPSED_REALTIME_WAKEUP,&#10;//                    SystemClock.elapsedRealtime() + 5000,  // 5 seconds later&#10;//                    restartPendingIntent&#10;//                )&#10;//            } else {&#10;//                Log.e(&quot;BackgroundMonitoringService&quot;, &quot;Cannot schedule exact alarms. Permission not granted.&quot;)&#10;//            }&#10;//        } catch (e: SecurityException) {&#10;//            Log.e(&quot;BackgroundMonitoringService&quot;, &quot;Failed to schedule exact alarm due to SecurityException&quot;, e)&#10;//        }&#10;//    }&#10;&#10;    /* Make sure the app restarts after the termination of it (WorkManager) */&#10;    private fun restartService() {&#10;        if (!isServiceRunning(this, BackgroundMonitoringService::class.java)) {&#10;            val workRequest = OneTimeWorkRequestBuilder&lt;RestartServiceWorker&gt;()&#10;                .setInitialDelay(5, TimeUnit.SECONDS) // Delay of 5 seconds&#10;                .build()&#10;&#10;            WorkManager.getInstance(this).enqueue(workRequest)&#10;        } else {&#10;            Log.i(&quot;BackgroundMonitoringService&quot;, &quot;Service is already running. No need to restart.&quot;)&#10;        }&#10;    }&#10;&#10;    private fun isServiceRunning(context: Context, serviceClass: Class&lt;*&gt;): Boolean {&#10;        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager&#10;        for (service in activityManager.getRunningServices(Int.MAX_VALUE)) {&#10;            if (serviceClass.name == service.service.className) {&#10;                return true&#10;            }&#10;        }&#10;        return false&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? {&#10;        return null&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        val channel = NotificationChannel(&#10;            &quot;MonitoringServiceChannel&quot;,&#10;            &quot;Monitoring Service Channel&quot;,&#10;            NotificationManager.IMPORTANCE_LOW&#10;        )&#10;        val manager = getSystemService(NotificationManager::class.java)&#10;        manager?.createNotificationChannel(channel)&#10;    }&#10;&#10;    private fun registerAllReceivers() {&#10;        // Register screen state receivers&#10;        val intentFilter = IntentFilter().apply {&#10;            addAction(Intent.ACTION_SCREEN_ON)&#10;            addAction(Intent.ACTION_SCREEN_OFF)&#10;            addAction(Intent.ACTION_USER_PRESENT)&#10;            addAction(Intent.ACTION_POWER_CONNECTED)&#10;            addAction(Intent.ACTION_POWER_DISCONNECTED)&#10;        }&#10;        intentEvtReceiver = IntentEvtReceiver()&#10;        registerReceiver(intentEvtReceiver, intentFilter)&#10;&#10;        // Register activity recognition&#10;        registerActivityUpdates()&#10;        registerActivityTransitions()&#10;    }&#10;&#10;    private fun registerActivityUpdates() {&#10;        val client = ActivityRecognition.getClient(this)&#10;        val intent = Intent(this, ActivityRecognitionReceiver::class.java)&#10;        val pendingIntent = PendingIntent.getBroadcast(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;&#10;        if (checkSelfPermission(Manifest.permission.ACTIVITY_RECOGNITION) == PackageManager.PERMISSION_GRANTED) {&#10;            client.requestActivityUpdates(10_000L, pendingIntent)&#10;                .addOnSuccessListener {&#10;                    Log.d(&quot;ActivityRecognition&quot;, &quot;Regular updates registered&quot;)&#10;                }&#10;                .addOnFailureListener {&#10;                    Log.e(&quot;ActivityRecognition&quot;, &quot;Failed to register regular updates&quot;, it)&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun registerActivityTransitions() {&#10;        val client = ActivityRecognition.getClient(this)&#10;        val intent = Intent(this, ActivityRecognitionReceiver::class.java)&#10;        val pendingIntent = PendingIntent.getBroadcast(&#10;            this, 1, intent, // different requestCode&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;        )&#10;&#10;        val transitions = listOf(&#10;            DetectedActivity.IN_VEHICLE,&#10;            DetectedActivity.ON_BICYCLE,&#10;            DetectedActivity.WALKING,&#10;            DetectedActivity.RUNNING,&#10;            DetectedActivity.STILL,&#10;        ).flatMap { activityType -&gt;&#10;            listOf(&#10;                ActivityTransition.Builder()&#10;                    .setActivityType(activityType)&#10;                    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_ENTER)&#10;                    .build(),&#10;                ActivityTransition.Builder()&#10;                    .setActivityType(activityType)&#10;                    .setActivityTransition(ActivityTransition.ACTIVITY_TRANSITION_EXIT)&#10;                    .build()&#10;            )&#10;        }&#10;&#10;        val request = ActivityTransitionRequest(transitions)&#10;&#10;        if (checkSelfPermission(Manifest.permission.ACTIVITY_RECOGNITION) == PackageManager.PERMISSION_GRANTED) {&#10;            client.requestActivityTransitionUpdates(request, pendingIntent)&#10;                .addOnSuccessListener {&#10;                    Log.d(&quot;ActivityRecognition&quot;, &quot;Transition updates registered&quot;)&#10;                }&#10;                .addOnFailureListener {&#10;                    Log.e(&quot;ActivityRecognition&quot;, &quot;Failed to register transitions&quot;, it)&#10;                }&#10;        } else {&#10;            Log.e(&quot;BackgroundMonitoringService&quot;, &quot;Permission not granted for activity recognition&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>